# 高性能原因浅析
Redis作为开源No-SQL技术的热门代表，在互联网公司里得到广泛的应用，其中一个最重要的原因是高性能,尤其是在秒杀/session缓存等场景，那么Redis自身是如何实现高性能呢？

要回答这个问题，就需要研读Redis源代码，从中理解Redis的设计思想与实现技巧，同时也提升自身的技术能力。

笔者这里从宏观层面，简明扼要的解释Redis高性能的原因。

## Redis整体介绍
Redis从问世之初就以高性能横行天下，究其整体来看，采用异步模型才是其最核心的原因。

这里先解释一下笔者所说异步模型的含义。有时候我们会遇到需要同时做多件事的场景，一般有两种解决方案，一种是并行，即有多个worker并行处理不同的事情，在多核cpu服务器上多进程/多线程执行，将某些可能阻塞主流程执行的任务交由后台进程/线程慢慢执行，而主流程继续执行。当后台执行完毕后再通知主流程进行一些收尾工作。另一种是并发，即时间片轮转执行不同任务，单一时间片里只执行一项任务，下一时间片执行另一项任务。

Redis异步模型就是指代上述两种方式，Redis将一些可能阻塞主流程的任务交由后台进程/线程异步执行，例如：数据持久化、删除大容量key，删除磁盘文件等。另一方面，Redis又会将多种实时却耗时任务并发执行，例如：TCP套接字的多路复用、定时过期数据的清理、集群节点之间的握手连接等。

有一种说法，Redis是单进程/单线程架构，避免了锁的使用，进而实现的高性能。这种说法不太准确。的确Redis的核心业务是以单进程/单线程执行，例如：API的请求应答；定时失效数据的淘汰等关键任务。但是随着Redis的逐步演进，Redis也在利用CPU多核硬件优势。其实从很早的版本开始，一直到目前的v5.0.5里面，Redis里有很多支援保障性的任务是通过多进程/多线程实现的，这其中也涉及到了信号/互斥锁/条件变量等同步机制。如果仅仅是通过单进程/单线程这单一方案是无法实现高性能。

单进程/单线程有其自身的优势，例如：无需锁等同步机制；天然支持原子性；对编码友好；易于调试定位问题等。但是劣势也是很明显，例如：无法发挥多核的优势；阻塞式函数的调用会极大的影响性能等。

Redis的作者充分挖掘各类技术方案的特点，优势结合，很好的利用单进程/单线程的优势，同时采用异步模型以解决其劣势。当然也不拘泥于此，也适时的引入多进程/多线程来解决某些特别需求，整体上有一种"博采众家之长为我所用"的感觉。

如下会从几个层面概括性的介绍Redis是如何组合使用这些技术方案。
## 接口协议层面

## 网络通信层面
Redis使用TCP/IP网络连接，内部支持多种平台下的多路复用技术，例如在Linux平台下使用epoll方案，并采用水平触发工作方式。在面对网络数据传输这一“慢速”场景下，将所有套接字的属性设置为Non-Block模式，只有在内核有可读写数据时应用层才会进行实际的读写操作，空闲时让出CPU进行其他已就位的操作。

<br>这里提两点Redis的编码小细节：
* 我们在编写服务端代码时，通常会将监听套接字置为Non-Block模式，并加入到多路复用函数里，当有新TCP连接完成了3次握手过程后变为可读事件等待应用层accept()获取。
<br/>这个方式基本上是多路复用的标准使用方式。而Redis在使用时更进一步的考虑了如何应对一批客户端在短时间内集中发起TCP连接。其实这个是有实际场景需求，因为在实际项目中，Redis通常作为缓存or数据库使用，调用方为保证服务的高可用，往往会采用连接池的方式维持一批与Redis的长连接，再叠加多节点负载均衡机制的考虑，当有调用方应用重启or网络中断重连时，服务端的确会有大批量的已经完成3次握手的新连接短时间集中等待accept()的情况发生。Redis服务端这里需要及时处理新连接以便双方进入较为“慢速”的数据传输过程，同时也不能因为集中处理这批新连接而阻塞其他任务的执行。
<br/>Redis采用的方式是轮番批量accept()，每轮至多处理1000个新连接，当达到此上限时，主动停止，让出CPU，等待下一轮的多路复用可读事件通知。

* 集群模式下，Redis主备节点之间因复制数据需要，会由备节点主动发起建立与主节点的TCP长连接，备节点使用Non-Block模式下的connect()方式。我们知道connect()方法会激活内核进行TCP 3次握手，而如果服务端未及时处理时，主动发起方的内核层面会尝试多次直至建立成功or超时，也就是说connect()可能会阻塞很久。

> If the client TCP receives no response to its SYN segment, ETIMEDOUT is returned. 4.4BSD, for example, sends one SYN when connect is called, another 6 seconds later, and another 24 seconds later (p. 828 of TCPv2). If no response is received after a total of 75 seconds, the error is returned.<br/>---《UNP》的connect函数章节

&emsp;&emsp;为避免可能的阻塞情况，Redis使用了Non-Block模式的connect()方式，而此情况下connect()函数会立即返回-1，并将errno置为EINPROGRESS以标识此connect激活的3次握手已在内核层面继续执行，目前只是暂未完毕。

> When a TCP socket is set to nonblocking and then connect is called, connect returns immediately with an error of EINPROGRESS but the TCP three-way handshake continues. We then check for either a successful or unsuccessful completion of the connection's establishment using select.<br/>---《UNP》的非阻塞connect章节

&emsp;&emsp;那么非阻塞式的connect()终态结果如何获知呢？
>Berkeley-derived implementations (and POSIX) have the following two rules regarding select and nonblocking connects:
<br/>1.When the connection completes successfully, the descriptor becomes writable(p. 531 of TCPv2).
<br/>2.When the connection establishment encounters an error, the descriptor becomes both readable and writable (p. 530 of TCPv2).<br/>---《UNP》的非阻塞connect章节

>The process can then obtain the value of so_error by fetching the SO_ERROR socket option. The integer value returned by getsockopt is the pending error for the socket.The value of so_error is then reset to 0 by the kernel (p. 547 of TCPv2).<br/>---《UNP》的通用socket属性章节

&emsp;&emsp;Redis就是采用通过epoll的读写事件通知，再调用getsockopt的SO_ERROR方式获取connect()终态结果。这个异步方式很好的避免了阻塞情况。

## 数据持久化层面
数据持久化一直是数据库的重头戏，因为这关系到性能，更关系着数据安全。Redis可以通过配置选项作为纯内存缓存使用，也可以开启持久化功能，以满足不同的业务场景需求。

<br>持久化必然会与磁盘打交道，相比于软件而言，硬件的演进是很漫长，从之前的机械式硬盘到固态盘，虽说IO性能有很大的提升，但是演进的速度是无法满足产品需求。所以Redis作者在数据持久化这一块做了大量的优化工作。

<br>Redis持久化数据有两种格式<span style="color:red;">[1]</span>
1. RDB格式，猜测是Redis Database的缩写:)。简单来说就是内存的磁盘快照数据，由可配置的时间间隔+更新次数激活快照数据落盘，为二进制格式。
2. AOF格式，是Append Only File的缩写。从字母含义也可以看出是一种将新数据追加到文件尾部的方式，为文本格式。随着客户命令的频繁执行，这个格式必然会增大磁盘空间的消耗，另外带来更为严重的隐患：Redis重启时数据加载回放慢。所以Redis会定期自动进行一项Rewrite AOF的任务，以精简AOF文件内容。

<br>之前提过，Redis核心业务是以单进程/单线程执行，而数据持久化又是一件非常耗时的任务。如何即能及时响应客户的读写操作，又能完成数据持久化呢？Redis作者在这一方面将异步模型以及各种IPC运用到令笔者叹为观止的程度，同时也能从中看到作者对操作系统尤其是文件操作有很深的理解。
* 运用fork()子进程将内存数据以RDB或者AOF格式保存到磁盘，而主进程继续响应客户读写操作。这里充分利用了多进程时的内存COW技术。Redis作者为此做了很多细致性的代码优化，可参考笔者分析的另一篇文章<span style="color:red;">[2]</span>
* 在子进程保存数据落盘时，主进程同时也在接收并执行客户的新命令。那么对于这些新命令是如何保证持久化的呢？
<br/>其实对于RDB格式来说，子进程无需关注这些新命令，因为RDB是对某一刻（fork函数返回的那一刻）内存数据的磁盘快照，新命令会由下一轮的RDB来持久化。
<br/>而对于AOF格式，Redis作者使用了无名管道pipe的方式，将新命令数据从主进程发送给子进程，同时结合异步方式，主进程里有专用的发送缓冲链表记录待发送的新命令，并且会在管道发送句柄可写事件通知时才会发送尽可能多的数据。子进程里也有专用的接收缓冲区，而且是在子进程每完成10K字节的AOF数据落盘时，从管道接收句柄里读取尽可能多的数据。这个过程是伴随着子进程AOF落盘整个期间一直在进行，而并非是等到子进程完成AOF落盘完结后，由主进程进行收尾工作，一次性将累积的所有新数据追加到AOF文件尾部，因为此方案可能会长时间阻塞主进程对用户的实时响应。Redis作者在这里采用了“化整为零”的策略处理新数据的同步。
* 新文件生成后，必然涉及到文件改名以及close旧文件等操作。
<br/>Redis这里使用了rename()函数：

>If oldname is not a directory, then any existing file named newname is removed during
the renaming operation.<span style="color:red;">[3]</span>

>If the link named by the new argument exists and the file's link count becomes 0 when it is removed and no process has the file open, the space occupied by the file shall be freed and the file shall no longer be accessible. If one or more processes have the file open when the last link is removed, the link shall be removed before rename() returns, but the removal of the file contents shall be postponed until all references to the file are closed.<span style="color:red;">[4]</span>

&emsp;&emsp;此函数如果在处理引用计数为0的文件时，实际上触发删除旧文件的动作。而删除文件会引起阻塞当前进程。
<br/>&emsp;&emsp;Redis在这里采用了一个小技巧，当前进程先open旧文件，使其引用计数>0，再执行rename()，这样旧文件不会因引用计数为0而触发删除操作。之后将先前open旧文件获得的句柄交由一个后台独立线程异步执行close操作，这样至多只会阻塞后台独立线程而不会对核心主进程造成任何影响。

## cluster集群层面
## 多进程的用途
## 多线程的用途


***参考资料***
1. UNIX Network Programming
2. https://redis.io/topics/persistence
3. 字典类型里的安全迭代器与非安全迭代器的差异
4. http://www.gnu.org/software/libc/manual/html_mono/libc.html#Renaming-Files
5. https://linux.die.net/man/3/rename


